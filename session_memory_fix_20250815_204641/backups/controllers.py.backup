"""
API控制器 - 核心版本

处理HTTP请求和响应。
"""

import logging
import time
import json
import os
from flask import request, jsonify, Response, stream_with_context, current_app
from qcli_api_service.models.core import ChatRequest, ChatResponse, Message
from qcli_api_service.services.session_manager import session_manager
from qcli_api_service.services.qcli_service import qcli_service
from qcli_api_service.utils.validators import input_validator
from qcli_api_service.utils.errors import (
    APIError, ValidationError, SessionError, ServiceError, InternalError,
    handle_qcli_error, log_error, ERRORS
)


logger = logging.getLogger(__name__)


def chat():
    """标准聊天接口"""
    try:
        # 解析请求
        data = request.get_json(force=True, silent=True)
        if data is None:
            error = ERRORS["EMPTY_REQUEST"]
            log_error(error, {"endpoint": "/api/v1/chat", "method": "POST"})
            return error.to_response()
        
        # 验证请求数据
        is_valid, error_msg = input_validator.validate_request_data(data)
        if not is_valid:
            error = ValidationError(error_msg)
            log_error(error, {"endpoint": "/api/v1/chat", "method": "POST", "data": data})
            return error.to_response()
        
        # 创建请求对象
        chat_request = ChatRequest(
            session_id=data.get('session_id'),
            message=input_validator.clean_message(data.get('message', '')),
            stream=data.get('stream', False)
        )
        
        # 获取或创建会话
        session = None
        if chat_request.session_id:
            session = session_manager.get_session(chat_request.session_id)
            if not session:
                error = SessionError("指定的会话不存在", session_id=chat_request.session_id)
                log_error(error, {"endpoint": "/api/v1/chat", "session_id": chat_request.session_id})
                return error.to_response()
        else:
            session = session_manager.create_session()
            chat_request.session_id = session.session_id
        
        # 添加用户消息到会话
        user_message = Message.create_user_message(chat_request.message)
        session_manager.add_message(session.session_id, user_message)
        
        # 获取对话上下文
        context = session_manager.get_context(session.session_id)
        
        # 调用Q CLI
        try:
            response_text = qcli_service.chat(
                chat_request.message, 
                context, 
                work_directory=session.work_directory
            )
        except RuntimeError as e:
            error = handle_qcli_error(e)
            log_error(error, {
                "endpoint": "/api/v1/chat", 
                "session_id": session.session_id,
                "message_length": len(chat_request.message)
            })
            return error.to_response()
        
        # 添加助手回复到会话
        assistant_message = Message.create_assistant_message(response_text)
        session_manager.add_message(session.session_id, assistant_message)
        
        # 返回响应
        response = ChatResponse.create(session.session_id, response_text)
        
        # 创建响应，确保中文正确显示
        response_data = {
            "session_id": response.session_id,
            "message": response.message,
            "timestamp": response.timestamp
        }
        
        # 使用自定义JSON响应函数
        return current_app.custom_jsonify(response_data)
        
    except APIError as e:
        # API错误已经处理过了，直接返回
        return e.to_response()
    except Exception as e:
        error = InternalError("聊天服务内部错误", original_error=e)
        log_error(error, {"endpoint": "/api/v1/chat", "method": "POST"})
        return error.to_response()


def stream_chat():
    """流式聊天接口"""
    try:
        # 解析请求
        data = request.get_json(force=True, silent=True)
        if data is None:
            error = ERRORS["EMPTY_REQUEST"]
            log_error(error, {"endpoint": "/api/v1/chat/stream", "method": "POST"})
            return error.to_response()
        
        # 验证请求数据
        is_valid, error_msg = input_validator.validate_request_data(data)
        if not is_valid:
            error = ValidationError(error_msg)
            log_error(error, {"endpoint": "/api/v1/chat/stream", "method": "POST", "data": data})
            return error.to_response()
        
        # 创建请求对象
        chat_request = ChatRequest(
            session_id=data.get('session_id'),
            message=input_validator.clean_message(data.get('message', '')),
            stream=True
        )
        
        # 获取或创建会话
        session = None
        if chat_request.session_id:
            session = session_manager.get_session(chat_request.session_id)
            if not session:
                error = SessionError("指定的会话不存在", session_id=chat_request.session_id)
                log_error(error, {"endpoint": "/api/v1/chat/stream", "session_id": chat_request.session_id})
                return error.to_response()
        else:
            session = session_manager.create_session()
            chat_request.session_id = session.session_id
        
        # 添加用户消息到会话
        user_message = Message.create_user_message(chat_request.message)
        session_manager.add_message(session.session_id, user_message)
        
        # 获取对话上下文
        context = session_manager.get_context(session.session_id)
        
        # 创建流式响应
        def generate():
            try:
                # 发送会话ID
                yield f"data: {{'session_id': '{session.session_id}', 'type': 'session'}}\n\n"
                
                # 收集完整回复用于保存到会话
                full_response = []
                
                # 流式调用Q CLI
                for chunk in qcli_service.stream_chat(
                    chat_request.message, 
                    context, 
                    work_directory=session.work_directory
                ):
                    full_response.append(chunk)
                    # 发送数据块
                    yield f"data: {{'message': '{_escape_json(chunk)}', 'type': 'chunk'}}\n\n"
                
                # 发送完成信号
                yield f"data: {{'type': 'done'}}\n\n"
                
                # 保存完整回复到会话
                if full_response:
                    complete_response = "\n".join(full_response)
                    assistant_message = Message.create_assistant_message(complete_response)
                    session_manager.add_message(session.session_id, assistant_message)
                
            except RuntimeError as e:
                # 处理Q CLI错误
                error = handle_qcli_error(e)
                log_error(error, {
                    "endpoint": "/api/v1/chat/stream", 
                    "session_id": session.session_id,
                    "message_length": len(chat_request.message)
                })
                # 发送详细错误信息
                error_data = {
                    'error': error.message,
                    'code': error.code,
                    'suggestions': error.suggestions,
                    'type': 'error'
                }
                yield f"data: {json.dumps(error_data, ensure_ascii=False)}\n\n"
            except Exception as e:
                error = InternalError("流式聊天内部错误", original_error=e)
                log_error(error, {"endpoint": "/api/v1/chat/stream", "session_id": session.session_id})
                error_data = {
                    'error': error.message,
                    'code': error.code,
                    'suggestions': error.suggestions,
                    'type': 'error'
                }
                yield f"data: {json.dumps(error_data, ensure_ascii=False)}\n\n"
        
        return Response(
            stream_with_context(generate()),
            mimetype='text/event-stream',
            headers={
                'Cache-Control': 'no-cache',
                'Connection': 'keep-alive',
                'Access-Control-Allow-Origin': '*',
                'Access-Control-Allow-Headers': 'Content-Type'
            }
        )
        
    except APIError as e:
        # API错误已经处理过了，直接返回
        return e.to_response()
    except Exception as e:
        error = InternalError("流式聊天服务内部错误", original_error=e)
        log_error(error, {"endpoint": "/api/v1/chat/stream", "method": "POST"})
        return error.to_response()


def health():
    """健康检查接口"""
    try:
        # 检查Q CLI可用性
        qcli_available = qcli_service.is_available()
        
        # 获取基本统计信息
        active_sessions = session_manager.get_active_session_count()
        
        status = "healthy" if qcli_available else "degraded"
        
        return current_app.custom_jsonify({
            "status": status,
            "timestamp": time.time(),
            "qcli_available": qcli_available,
            "active_sessions": active_sessions,
            "version": "1.0.0"
        })
        
    except Exception as e:
        error = InternalError("健康检查失败", original_error=e)
        log_error(error, {"endpoint": "/health", "method": "GET"})
        
        # 健康检查返回特殊格式
        response_data = {
            "status": "unhealthy",
            "timestamp": time.time(),
            "error": error.message,
            "code": error.code
        }
        response = current_app.custom_jsonify(response_data)
        response.status_code = 500
        return response


def create_session():
    """创建会话接口"""
    try:
        session = session_manager.create_session()
        
        response_data = {
            "session_id": session.session_id,
            "created_at": session.created_at
        }
        response = current_app.custom_jsonify(response_data)
        response.status_code = 201
        return response
        
    except Exception as e:
        error = InternalError("创建会话失败", original_error=e)
        log_error(error, {"endpoint": "/api/v1/sessions", "method": "POST"})
        return error.to_response()


def get_session(session_id: str):
    """获取会话信息接口"""
    try:
        session_info = session_manager.get_session_info(session_id)
        
        if not session_info:
            error = SessionError("指定的会话不存在", session_id=session_id)
            log_error(error, {"endpoint": f"/api/v1/sessions/{session_id}", "method": "GET"})
            return error.to_response()
        
        return current_app.custom_jsonify(session_info)
        
    except Exception as e:
        error = InternalError("获取会话信息失败", original_error=e)
        log_error(error, {"endpoint": f"/api/v1/sessions/{session_id}", "method": "GET"})
        return error.to_response()


def delete_session(session_id: str):
    """删除会话接口"""
    try:
        success = session_manager.delete_session(session_id)
        
        if not success:
            error = SessionError("指定的会话不存在", session_id=session_id)
            log_error(error, {"endpoint": f"/api/v1/sessions/{session_id}", "method": "DELETE"})
            return error.to_response()
        
        return current_app.custom_jsonify({"message": "会话已删除"})
        
    except Exception as e:
        error = InternalError("删除会话失败", original_error=e)
        log_error(error, {"endpoint": f"/api/v1/sessions/{session_id}", "method": "DELETE"})
        return error.to_response()


def get_session_files(session_id: str):
    """获取会话文件列表接口"""
    try:
        work_directory = session_manager.get_session_work_directory(session_id)
        
        if not work_directory:
            error = SessionError("指定的会话不存在", session_id=session_id)
            log_error(error, {"endpoint": f"/api/v1/sessions/{session_id}/files", "method": "GET"})
            return error.to_response()
        
        # 获取目录中的文件列表
        files = []
        if os.path.exists(work_directory):
            for root, dirs, filenames in os.walk(work_directory):
                for filename in filenames:
                    file_path = os.path.join(root, filename)
                    relative_path = os.path.relpath(file_path, work_directory)
                    file_size = os.path.getsize(file_path)
                    file_mtime = os.path.getmtime(file_path)
                    
                    files.append({
                        "name": filename,
                        "path": relative_path,
                        "size": file_size,
                        "modified_time": file_mtime
                    })
        
        return current_app.custom_jsonify({
            "session_id": session_id,
            "work_directory": os.path.relpath(work_directory),
            "absolute_work_directory": work_directory,
            "files": files,
            "file_count": len(files)
        })
        
    except Exception as e:
        error = InternalError("获取会话文件列表失败", original_error=e)
        log_error(error, {"endpoint": f"/api/v1/sessions/{session_id}/files", "method": "GET"})
        return error.to_response()


# 旧的_error_response函数已被新的错误处理系统替代


def _escape_json(text: str) -> str:
    """转义JSON字符串中的特殊字符"""
    return text.replace('\\', '\\\\').replace('"', '\\"').replace('\n', '\\n').replace('\r', '\\r')