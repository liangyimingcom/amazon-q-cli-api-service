# 🔍 当前实现分析

## 问题根源

### 当前错误的实现方式
1. **每次调用都创建新进程**: 每个API请求都启动新的 `q chat` 进程
2. **通过临时文件发送消息**: 使用 `tempfile` 和 `stdin` 重定向
3. **立即退出进程**: 每次调用后都发送 `/quit` 命令
4. **重复发送上下文**: 将历史对话重新发送给新进程

### 正确的实现方式
1. **每个会话一个持久进程**: 为每个API会话维护一个长期运行的 `q chat` 进程
2. **直接通过stdin交互**: 通过进程的stdin直接发送新消息
3. **保持进程活跃**: 不发送 `/quit`，让进程持续运行
4. **只发送新消息**: 利用 `q chat` 的内置记忆能力

## 🔧 修复设计

### 新的架构
```
API会话 1 ←→ Q Chat进程 1 (持续运行)
API会话 2 ←→ Q Chat进程 2 (持续运行)  
API会话 3 ←→ Q Chat进程 3 (持续运行)
```

### 进程生命周期管理
1. **会话创建时**: 启动新的 `q chat --trust-all-tools` 进程
2. **消息发送时**: 直接向进程stdin写入新消息
3. **会话删除时**: 发送 `/quit` 并清理进程
4. **异常处理**: 检测进程状态，必要时重启

### 实现要点
1. **进程池管理**: 为每个会话ID维护对应的进程
2. **线程安全**: 确保多个请求不会冲突
3. **资源清理**: 及时清理僵尸进程
4. **错误恢复**: 进程崩溃时的恢复机制

## 📝 实现计划

### 第一步：创建会话进程管理器
- `SessionProcessManager` 类
- 管理会话ID到进程的映射
- 处理进程启动、通信、清理

### 第二步：修改QCLIService
- 移除临时文件逻辑
- 使用会话进程管理器
- 简化消息发送逻辑

### 第三步：更新会话管理
- 会话创建时启动Q Chat进程
- 会话删除时清理进程
- 添加进程健康检查

### 第四步：测试验证
- 验证会话记忆功能
- 测试进程清理
- 压力测试多会话