# 会话隔离测试矩阵

## 测试目标
验证会话隔离功能的完整性，确保每个会话在独立的工作目录中运行，文件操作互不干扰。

## 测试环境
- 服务地址: http://localhost:8080
- 测试工具: pytest, requests, os, pathlib
- 配置: SESSIONS_BASE_DIR=sessions

## 1. 工作目录管理测试

### 1.1 目录创建和结构测试
| 测试用例ID | 测试描述 | 测试步骤 | 预期结果 | 优先级 |
|-----------|---------|---------|---------|--------|
| SI001 | 会话目录自动创建 | 创建新会话 | 自动创建对应工作目录 | 高 |
| SI002 | 目录命名规范 | 检查目录名称 | 目录名为session_id | 高 |
| SI003 | 目录路径正确性 | 验证目录路径 | 在SESSIONS_BASE_DIR下 | 高 |
| SI004 | 目录权限设置 | 检查目录权限 | 具有读写权限 | 中 |
| SI005 | 嵌套目录支持 | 在会话中创建子目录 | 支持子目录创建 | 中 |

### 1.2 目录清理测试
| 测试用例ID | 测试描述 | 测试步骤 | 预期结果 | 优先级 |
|-----------|---------|---------|---------|--------|
| SI006 | 会话删除时目录清理 | 删除会话 | 对应目录被完全删除 | 高 |
| SI007 | 目录内容完全清理 | 删除包含文件的会话 | 所有文件和子目录被删除 | 高 |
| SI008 | 清理操作原子性 | 删除过程中断 | 不留下部分清理的目录 | 中 |
| SI009 | 清理失败处理 | 文件被占用时删除 | 优雅处理清理失败 | 中 |

## 2. 文件操作隔离测试

### 2.1 文件创建隔离
| 测试用例ID | 测试描述 | 测试步骤 | 预期结果 | 优先级 |
|-----------|---------|---------|---------|--------|
| SI010 | 同名文件隔离 | 不同会话创建同名文件 | 文件在各自目录中 | 高 |
| SI011 | 文件路径隔离 | 检查文件绝对路径 | 路径包含会话ID | 高 |
| SI012 | 文件内容独立 | 不同会话写入不同内容 | 内容不会混淆 | 高 |
| SI013 | 批量文件创建 | 在会话中创建多个文件 | 所有文件在正确目录 | 中 |

### 2.2 文件访问控制
| 测试用例ID | 测试描述 | 测试步骤 | 预期结果 | 优先级 |
|-----------|---------|---------|---------|--------|
| SI014 | 跨会话文件访问限制 | 尝试访问其他会话文件 | 访问被拒绝或失败 | 高 |
| SI015 | 系统目录访问限制 | 尝试访问系统目录 | 被限制在会话目录内 | 高 |
| SI016 | 父目录访问限制 | 使用../访问父目录 | 访问被限制 | 高 |
| SI017 | 符号链接处理 | 创建指向外部的符号链接 | 正确处理或拒绝 | 中 |## 3. 
会话文件API测试

### 3.1 文件列表功能
| 测试用例ID | 测试描述 | 测试步骤 | 预期结果 | 优先级 |
|-----------|---------|---------|---------|--------|
| SI018 | 空目录文件列表 | 新会话获取文件列表 | 返回空文件数组 | 高 |
| SI019 | 单文件列表 | 创建一个文件后获取列表 | 返回包含该文件的列表 | 高 |
| SI020 | 多文件列表 | 创建多个文件后获取列表 | 返回所有文件信息 | 高 |
| SI021 | 文件信息完整性 | 检查文件列表项 | 包含name, path, size, modified_time | 高 |
| SI022 | 子目录文件列表 | 在子目录中创建文件 | 递归列出所有文件 | 中 |

### 3.2 文件元数据验证
| 测试用例ID | 测试描述 | 测试步骤 | 预期结果 | 优先级 |
|-----------|---------|---------|---------|--------|
| SI023 | 文件大小准确性 | 创建已知大小文件 | size字段准确 | 高 |
| SI024 | 修改时间准确性 | 检查文件修改时间 | modified_time准确 | 中 |
| SI025 | 文件路径相对性 | 检查path字段 | 相对于会话目录的路径 | 高 |
| SI026 | 文件名处理 | 包含特殊字符的文件名 | 正确处理和显示 | 中 |

## 4. 并发隔离测试

### 4.1 多会话并发操作
| 测试用例ID | 测试描述 | 测试步骤 | 预期结果 | 优先级 |
|-----------|---------|---------|---------|--------|
| SI027 | 并发文件创建 | 多个会话同时创建文件 | 文件在各自目录中 | 高 |
| SI028 | 并发目录操作 | 多个会话同时操作目录 | 操作互不干扰 | 高 |
| SI029 | 并发文件读写 | 多个会话同时读写文件 | 数据不混淆 | 高 |
| SI030 | 并发会话删除 | 同时删除多个会话 | 目录正确清理 | 中 |

### 4.2 资源竞争测试
| 测试用例ID | 测试描述 | 测试步骤 | 预期结果 | 优先级 |
|-----------|---------|---------|---------|--------|
| SI031 | 同名目录竞争 | 同时创建相同名称的会话 | 每个会话有唯一目录 | 高 |
| SI032 | 磁盘空间竞争 | 多个会话同时写大文件 | 合理分配空间 | 中 |
| SI033 | 文件句柄竞争 | 大量文件操作 | 正确管理文件句柄 | 中 |

## 5. 安全隔离测试

### 5.1 路径遍历攻击防护
| 测试用例ID | 测试描述 | 攻击向量 | 预期防护 | 优先级 |
|-----------|---------|---------|---------|--------|
| SI034 | 相对路径攻击 | 使用../访问上级目录 | 被阻止或限制 | 高 |
| SI035 | 绝对路径攻击 | 使用绝对路径访问系统文件 | 被阻止 | 高 |
| SI036 | 符号链接攻击 | 创建指向系统文件的链接 | 被检测和阻止 | 高 |
| SI037 | 路径注入攻击 | 在文件名中注入路径 | 被正确处理 | 中 |

### 5.2 权限控制测试
| 测试用例ID | 测试描述 | 测试步骤 | 预期结果 | 优先级 |
|-----------|---------|---------|---------|--------|
| SI038 | 会话目录权限 | 检查目录权限设置 | 仅会话可访问 | 中 |
| SI039 | 文件权限继承 | 在会话中创建文件 | 继承正确权限 | 中 |
| SI040 | 跨用户隔离 | 不同用户的会话 | 完全隔离 | 低 |

## 6. 数据一致性测试

### 6.1 文件系统一致性
| 测试用例ID | 测试描述 | 测试步骤 | 预期结果 | 优先级 |
|-----------|---------|---------|---------|--------|
| SI041 | 文件创建一致性 | 创建文件后立即查询 | API和文件系统一致 | 高 |
| SI042 | 文件删除一致性 | 删除文件后查询 | 文件不在列表中 | 高 |
| SI043 | 目录状态一致性 | 各种操作后检查状态 | API返回与实际一致 | 高 |
| SI044 | 缓存一致性 | 文件变更后的缓存更新 | 缓存及时更新 | 中 |

### 6.2 异常恢复一致性
| 测试用例ID | 测试描述 | 异常情况 | 预期恢复 | 优先级 |
|-----------|---------|---------|---------|--------|
| SI045 | 服务重启后恢复 | 重启服务后检查会话 | 会话目录状态正确 | 中 |
| SI046 | 异常中断恢复 | 操作中断后恢复 | 数据状态一致 | 中 |
| SI047 | 部分失败恢复 | 部分文件操作失败 | 保持一致状态 | 中 |

## 测试脚本示例

```python
import requests
import os
import tempfile
import threading
import pytest
from pathlib import Path

BASE_URL = "http://localhost:8080"

class TestSessionIsolation:
    
    def test_session_directory_creation(self):
        """SI001: 测试会话目录自动创建"""
        # 创建会话
        response = requests.post(f"{BASE_URL}/api/v1/sessions")
        session_id = response.json()["session_id"]
        
        # 获取会话信息
        response = requests.get(f"{BASE_URL}/api/v1/sessions/{session_id}")
        session_info = response.json()
        
        # 验证工作目录信息
        assert "work_directory" in session_info
        assert "absolute_work_directory" in session_info
        
        work_dir = session_info["work_directory"]
        abs_work_dir = session_info["absolute_work_directory"]
        
        # 验证目录命名和路径
        assert session_id in work_dir
        assert os.path.exists(abs_work_dir)
        assert os.path.isdir(abs_work_dir)
    
    def test_file_creation_isolation(self):
        """SI010: 测试同名文件隔离"""
        # 创建两个会话
        session1_resp = requests.post(f"{BASE_URL}/api/v1/sessions")
        session1_id = session1_resp.json()["session_id"]
        
        session2_resp = requests.post(f"{BASE_URL}/api/v1/sessions")
        session2_id = session2_resp.json()["session_id"]
        
        # 在两个会话中创建同名文件
        requests.post(f"{BASE_URL}/api/v1/chat", json={
            "session_id": session1_id,
            "message": "请创建一个名为test.txt的文件，内容为'Session 1'"
        })
        
        requests.post(f"{BASE_URL}/api/v1/chat", json={
            "session_id": session2_id,
            "message": "请创建一个名为test.txt的文件，内容为'Session 2'"
        })
        
        # 检查两个会话的文件列表
        files1_resp = requests.get(f"{BASE_URL}/api/v1/sessions/{session1_id}/files")
        files2_resp = requests.get(f"{BASE_URL}/api/v1/sessions/{session2_id}/files")
        
        files1 = files1_resp.json()["files"]
        files2 = files2_resp.json()["files"]
        
        # 验证两个会话都有test.txt文件
        assert any(f["name"] == "test.txt" for f in files1)
        assert any(f["name"] == "test.txt" for f in files2)
        
        # 验证文件在不同目录中
        session1_info = requests.get(f"{BASE_URL}/api/v1/sessions/{session1_id}").json()
        session2_info = requests.get(f"{BASE_URL}/api/v1/sessions/{session2_id}").json()
        
        assert session1_info["work_directory"] != session2_info["work_directory"]
    
    def test_concurrent_file_operations(self):
        """SI027: 测试并发文件创建"""
        sessions = []
        
        # 创建5个会话
        for i in range(5):
            response = requests.post(f"{BASE_URL}/api/v1/sessions")
            sessions.append(response.json()["session_id"])
        
        def create_file_in_session(session_id, file_suffix):
            requests.post(f"{BASE_URL}/api/v1/chat", json={
                "session_id": session_id,
                "message": f"请创建一个名为file_{file_suffix}.txt的文件"
            })
        
        # 并发在每个会话中创建文件
        threads = []
        for i, session_id in enumerate(sessions):
            thread = threading.Thread(
                target=create_file_in_session, 
                args=(session_id, i)
            )
            threads.append(thread)
            thread.start()
        
        # 等待所有线程完成
        for thread in threads:
            thread.join()
        
        # 验证每个会话都有对应的文件
        for i, session_id in enumerate(sessions):
            files_resp = requests.get(f"{BASE_URL}/api/v1/sessions/{session_id}/files")
            files = files_resp.json()["files"]
            
            expected_filename = f"file_{i}.txt"
            assert any(f["name"] == expected_filename for f in files)
    
    def test_session_deletion_cleanup(self):
        """SI006: 测试会话删除时目录清理"""
        # 创建会话
        response = requests.post(f"{BASE_URL}/api/v1/sessions")
        session_id = response.json()["session_id"]
        
        # 获取工作目录路径
        session_info = requests.get(f"{BASE_URL}/api/v1/sessions/{session_id}").json()
        abs_work_dir = session_info["absolute_work_directory"]
        
        # 在会话中创建一些文件
        requests.post(f"{BASE_URL}/api/v1/chat", json={
            "session_id": session_id,
            "message": "请创建几个测试文件"
        })
        
        # 验证目录和文件存在
        assert os.path.exists(abs_work_dir)
        
        # 删除会话
        delete_resp = requests.delete(f"{BASE_URL}/api/v1/sessions/{session_id}")
        assert delete_resp.status_code == 200
        
        # 验证目录被完全清理
        assert not os.path.exists(abs_work_dir)
    
    def test_file_list_api(self):
        """SI019-SI021: 测试文件列表API"""
        # 创建会话
        response = requests.post(f"{BASE_URL}/api/v1/sessions")
        session_id = response.json()["session_id"]
        
        # 初始文件列表应为空
        files_resp = requests.get(f"{BASE_URL}/api/v1/sessions/{session_id}/files")
        assert files_resp.status_code == 200
        
        initial_files = files_resp.json()["files"]
        assert len(initial_files) == 0
        
        # 创建一个文件
        requests.post(f"{BASE_URL}/api/v1/chat", json={
            "session_id": session_id,
            "message": "请创建一个名为example.py的Python文件"
        })
        
        # 获取更新后的文件列表
        files_resp = requests.get(f"{BASE_URL}/api/v1/sessions/{session_id}/files")
        files_data = files_resp.json()
        files = files_data["files"]
        
        # 验证文件列表信息
        assert len(files) > 0
        assert "session_id" in files_data
        assert "work_directory" in files_data
        assert "file_count" in files_data
        
        # 验证文件信息完整性
        for file_info in files:
            assert "name" in file_info
            assert "path" in file_info
            assert "size" in file_info
            assert "modified_time" in file_info
            
            # 验证数据类型
            assert isinstance(file_info["size"], int)
            assert isinstance(file_info["modified_time"], (int, float))
    
    def test_path_traversal_protection(self):
        """SI034-SI036: 测试路径遍历攻击防护"""
        # 创建会话
        response = requests.post(f"{BASE_URL}/api/v1/sessions")
        session_id = response.json()["session_id"]
        
        # 尝试各种路径遍历攻击
        attack_vectors = [
            "请创建文件 ../../../etc/passwd",
            "请访问文件 /etc/hosts",
            "请创建文件 ..\\..\\windows\\system32\\config\\sam",
            "请创建符号链接指向 /etc/passwd"
        ]
        
        for attack in attack_vectors:
            response = requests.post(f"{BASE_URL}/api/v1/chat", json={
                "session_id": session_id,
                "message": attack
            })
            
            # 验证请求被正确处理（不应该导致系统文件被访问）
            assert response.status_code == 200
            
            # 检查文件列表，确保没有创建危险文件
            files_resp = requests.get(f"{BASE_URL}/api/v1/sessions/{session_id}/files")
            files = files_resp.json()["files"]
            
            # 验证没有创建系统文件或危险路径
            for file_info in files:
                assert not file_info["path"].startswith("/")
                assert ".." not in file_info["path"]
                assert not any(dangerous in file_info["name"].lower() 
                             for dangerous in ["passwd", "hosts", "sam"])
```

## 自动化测试工具

### 目录监控工具
```python
import os
import time
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

class SessionDirectoryMonitor(FileSystemEventHandler):
    """监控会话目录变化"""
    
    def __init__(self):
        self.events = []
    
    def on_created(self, event):
        self.events.append(("created", event.src_path))
    
    def on_deleted(self, event):
        self.events.append(("deleted", event.src_path))
    
    def on_modified(self, event):
        self.events.append(("modified", event.src_path))

def monitor_session_directory(base_dir, duration=10):
    """监控会话目录变化"""
    monitor = SessionDirectoryMonitor()
    observer = Observer()
    observer.schedule(monitor, base_dir, recursive=True)
    observer.start()
    
    time.sleep(duration)
    observer.stop()
    observer.join()
    
    return monitor.events
```

### 文件系统一致性检查
```python
def verify_filesystem_consistency(session_id):
    """验证文件系统一致性"""
    # 通过API获取文件列表
    api_files = requests.get(
        f"{BASE_URL}/api/v1/sessions/{session_id}/files"
    ).json()["files"]
    
    # 通过文件系统直接获取文件列表
    session_info = requests.get(
        f"{BASE_URL}/api/v1/sessions/{session_id}"
    ).json()
    
    work_dir = Path(session_info["absolute_work_directory"])
    fs_files = []
    
    if work_dir.exists():
        for file_path in work_dir.rglob("*"):
            if file_path.is_file():
                relative_path = file_path.relative_to(work_dir)
                fs_files.append({
                    "name": file_path.name,
                    "path": str(relative_path),
                    "size": file_path.stat().st_size
                })
    
    # 比较API和文件系统结果
    api_file_paths = {f["path"] for f in api_files}
    fs_file_paths = {f["path"] for f in fs_files}
    
    return api_file_paths == fs_file_paths
```

## 性能基准测试

### 大量文件处理测试
```python
def test_large_file_handling():
    """测试大量文件处理性能"""
    response = requests.post(f"{BASE_URL}/api/v1/sessions")
    session_id = response.json()["session_id"]
    
    # 创建100个文件
    start_time = time.time()
    
    for i in range(100):
        requests.post(f"{BASE_URL}/api/v1/chat", json={
            "session_id": session_id,
            "message": f"请创建文件 file_{i:03d}.txt"
        })
    
    creation_time = time.time() - start_time
    
    # 获取文件列表
    start_time = time.time()
    files_resp = requests.get(f"{BASE_URL}/api/v1/sessions/{session_id}/files")
    list_time = time.time() - start_time
    
    files = files_resp.json()["files"]
    
    # 验证性能指标
    assert creation_time < 60  # 创建100个文件应在60秒内完成
    assert list_time < 1       # 列出文件应在1秒内完成
    assert len(files) >= 100   # 应该有至少100个文件
```

## 成功标准

- 会话目录隔离率 100%
- 文件操作隔离率 100%
- 路径遍历攻击防护率 100%
- 并发操作正确性 ≥ 99%
- 目录清理完整性 100%
- API与文件系统一致性 100%
- 文件列表API准确性 100%

## 测试执行计划

### 阶段1: 基础隔离功能
- SI001-SI009: 目录管理基础功能
- SI010-SI017: 文件操作隔离

### 阶段2: API功能验证
- SI018-SI026: 文件列表API功能
- SI041-SI044: 数据一致性验证

### 阶段3: 安全和并发测试
- SI027-SI033: 并发隔离测试
- SI034-SI040: 安全隔离测试

### 阶段4: 异常和性能测试
- SI045-SI047: 异常恢复测试
- 性能基准测试
- 长期稳定性测试