# 错误处理测试矩阵

## 测试目标
验证系统在各种异常情况下的错误处理能力，确保系统稳定性和用户体验。

## 测试环境
- 服务地址: http://localhost:8080
- 测试工具: pytest, requests, threading
- 错误监控: 日志分析、异常捕获

## 1. 输入验证错误处理

### 1.1 消息格式验证
| 测试用例ID | 测试描述 | 输入数据 | 预期错误类型 | 预期状态码 | 优先级 |
|-----------|---------|---------|-------------|-----------|--------|
| EH001 | 空消息处理 | {"message": ""} | 参数验证错误 | 400 | 高 |
| EH002 | 缺少消息字段 | {} | 必需字段缺失 | 400 | 高 |
| EH003 | 消息类型错误 | {"message": 123} | 类型验证错误 | 400 | 高 |
| EH004 | 超长消息 | {"message": "x"*5000} | 长度限制错误 | 400 | 高 |
| EH005 | null消息 | {"message": null} | 空值错误 | 400 | 中 |

### 1.2 会话ID验证
| 测试用例ID | 测试描述 | 输入数据 | 预期错误类型 | 预期状态码 | 优先级 |
|-----------|---------|---------|-------------|-----------|--------|
| EH006 | 无效会话ID格式 | {"session_id": "invalid"} | 格式验证错误 | 400 | 高 |
| EH007 | 不存在的会话ID | {"session_id": "valid-uuid-not-exist"} | 资源不存在 | 404 | 高 |
| EH008 | 过期的会话ID | 使用过期会话ID | 会话过期错误 | 404 | 高 |
| EH009 | 空会话ID | {"session_id": ""} | 参数验证错误 | 400 | 中 |
| EH010 | null会话ID | {"session_id": null} | 空值错误 | 400 | 中 |

### 1.3 HTTP请求格式验证
| 测试用例ID | 测试描述 | 请求格式 | 预期错误类型 | 预期状态码 | 优先级 |
|-----------|---------|---------|-------------|-----------|--------|
| EH011 | 错误Content-Type | text/plain | 媒体类型错误 | 400 | 高 |
| EH012 | 无效JSON格式 | {invalid json} | JSON解析错误 | 400 | 高 |
| EH013 | 空请求体 | 无请求体 | 请求体缺失 | 400 | 高 |
| EH014 | 错误HTTP方法 | PUT /api/v1/sessions | 方法不允许 | 405 | 中 |
| EH015 | 不支持的编码 | 错误字符编码 | 编码错误 | 400 | 低 |

## 2. 系统资源错误处理

### 2.1 内存相关错误
| 测试用例ID | 测试描述 | 触发条件 | 预期处理 | 优先级 |
|-----------|---------|---------|---------|--------|
| EH016 | 内存不足处理 | 系统内存耗尽 | 优雅降级，返回503 | 高 |
| EH017 | 会话内存限制 | 单会话占用过多内存 | 限制会话资源 | 中 |
| EH018 | 历史消息清理 | 超过MAX_HISTORY_LENGTH | 自动清理旧消息 | 高 |
| EH019 | 内存泄漏检测 | 长时间运行 | 内存使用稳定 | 中 |

### 2.2 存储空间错误
| 测试用例ID | 测试描述 | 触发条件 | 预期处理 | 优先级 |
|-----------|---------|---------|---------|--------|
| EH020 | 磁盘空间不足 | 存储空间耗尽 | 返回存储错误 | 高 |
| EH021 | 文件创建失败 | 权限不足或空间不足 | 优雅处理文件错误 | 高 |
| EH022 | 目录创建失败 | 会话目录创建失败 | 返回创建错误 | 高 |
| EH023 | 文件删除失败 | 文件被占用 | 记录错误，继续执行 | 中 |

### 2.3 网络和连接错误
| 测试用例ID | 测试描述 | 触发条件 | 预期处理 | 优先级 |
|-----------|---------|---------|---------|--------|
| EH024 | 连接超时 | 客户端连接超时 | 超时错误处理 | 高 |
| EH025 | 连接中断 | 网络连接中断 | 连接中断处理 | 高 |
| EH026 | 并发连接限制 | 超过最大连接数 | 拒绝新连接 | 中 |
| EH027 | 流式连接异常 | SSE连接异常 | 发送error事件 | 高 |

## 3. 外部依赖错误处理

### 3.1 Amazon Q CLI错误
| 测试用例ID | 测试描述 | 触发条件 | 预期处理 | 优先级 |
|-----------|---------|---------|---------|--------|
| EH028 | Q CLI不可用 | Q CLI服务异常 | 返回503服务不可用 | 高 |
| EH029 | Q CLI超时 | Q CLI响应超时 | 超时错误处理 | 高 |
| EH030 | Q CLI返回错误 | Q CLI执行失败 | 转换为用户友好错误 | 高 |
| EH031 | Q CLI权限错误 | 权限配置问题 | 权限错误提示 | 中 |
| EH032 | Q CLI版本不兼容 | 版本兼容性问题 | 版本错误提示 | 低 |

### 3.2 系统依赖错误
| 测试用例ID | 测试描述 | 触发条件 | 预期处理 | 优先级 |
|-----------|---------|---------|---------|--------|
| EH033 | Python环境错误 | Python环境异常 | 环境错误处理 | 中 |
| EH034 | 依赖包缺失 | 必需包未安装 | 依赖错误提示 | 中 |
| EH035 | 系统命令失败 | 系统调用失败 | 命令错误处理 | 中 |

## 4. 并发和竞争条件错误

### 4.1 资源竞争错误
| 测试用例ID | 测试描述 | 触发条件 | 预期处理 | 优先级 |
|-----------|---------|---------|---------|--------|
| EH036 | 会话ID冲突 | 同时创建相同ID会话 | 确保ID唯一性 | 高 |
| EH037 | 文件访问冲突 | 同时访问同一文件 | 文件锁定机制 | 中 |
| EH038 | 目录删除竞争 | 同时删除同一目录 | 原子性删除操作 | 中 |
| EH039 | 内存竞争 | 多线程内存访问 | 线程安全处理 | 高 |

### 4.2 死锁和阻塞
| 测试用例ID | 测试描述 | 触发条件 | 预期处理 | 优先级 |
|-----------|---------|---------|---------|--------|
| EH040 | 死锁检测 | 资源死锁情况 | 死锁检测和恢复 | 高 |
| EH041 | 长时间阻塞 | 操作长时间阻塞 | 超时机制 | 高 |
| EH042 | 资源泄漏 | 资源未正确释放 | 资源清理机制 | 中 |

## 5. 业务逻辑错误处理

### 5.1 会话状态错误
| 测试用例ID | 测试描述 | 触发条件 | 预期处理 | 优先级 |
|-----------|---------|---------|---------|--------|
| EH043 | 会话状态不一致 | 会话状态异常 | 状态修复或重置 | 高 |
| EH044 | 重复删除会话 | 多次删除同一会话 | 幂等性处理 | 中 |
| EH045 | 会话数据损坏 | 会话数据异常 | 数据恢复或重建 | 中 |

### 5.2 上下文处理错误
| 测试用例ID | 测试描述 | 触发条件 | 预期处理 | 优先级 |
|-----------|---------|---------|---------|--------|
| EH046 | 上下文数据损坏 | 历史消息异常 | 上下文重建 | 中 |
| EH047 | 上下文过大 | 上下文超出限制 | 自动截断 | 中 |
| EH048 | 上下文序列化错误 | 序列化失败 | 错误恢复 | 低 |

## 6. 安全相关错误处理

### 6.1 恶意输入处理
| 测试用例ID | 测试描述 | 恶意输入 | 预期处理 | 优先级 |
|-----------|---------|---------|---------|--------|
| EH049 | SQL注入尝试 | '; DROP TABLE; -- | 输入清理和拒绝 | 高 |
| EH050 | XSS攻击尝试 | <script>alert('xss')</script> | HTML转义处理 | 高 |
| EH051 | 路径遍历攻击 | ../../../etc/passwd | 路径验证和限制 | 高 |
| EH052 | 命令注入尝试 | $(rm -rf /) | 命令过滤和阻止 | 高 |
| EH053 | 模板注入尝试 | {{7*7}} | 模板安全处理 | 中 |

### 6.2 访问控制错误
| 测试用例ID | 测试描述 | 触发条件 | 预期处理 | 优先级 |
|-----------|---------|---------|---------|--------|
| EH054 | 未授权访问 | 访问其他会话资源 | 访问拒绝 | 高 |
| EH055 | 权限提升尝试 | 尝试获取系统权限 | 权限检查和拒绝 | 高 |
| EH056 | 资源枚举攻击 | 枚举系统资源 | 信息泄露防护 | 中 |

## 测试脚本示例

```python
import pytest
import requests
import threading
import time
import json
from unittest.mock import patch

BASE_URL = "http://localhost:8080"

class TestInputValidationErrors:
    """输入验证错误处理测试"""
    
    def test_empty_message_error(self):
        """EH001: 空消息处理"""
        response = requests.post(
            f"{BASE_URL}/api/v1/chat",
            json={"message": ""}
        )
        assert response.status_code == 400
        
        data = response.json()
        assert "error" in data
        assert "message" in data["error"].lower() or "empty" in data["error"].lower()
    
    def test_missing_message_field(self):
        """EH002: 缺少消息字段"""
        response = requests.post(
            f"{BASE_URL}/api/v1/chat",
            json={}
        )
        assert response.status_code == 400
        
        data = response.json()
        assert "error" in data
        assert "message" in data["error"].lower() or "required" in data["error"].lower()
    
    def test_wrong_message_type(self):
        """EH003: 消息类型错误"""
        response = requests.post(
            f"{BASE_URL}/api/v1/chat",
            json={"message": 123}
        )
        assert response.status_code == 400
        
        data = response.json()
        assert "error" in data
    
    def test_message_too_long(self):
        """EH004: 超长消息"""
        long_message = "x" * 5000
        response = requests.post(
            f"{BASE_URL}/api/v1/chat",
            json={"message": long_message}
        )
        assert response.status_code == 400
        
        data = response.json()
        assert "error" in data
        assert "length" in data["error"].lower() or "long" in data["error"].lower()
    
    def test_null_message(self):
        """EH005: null消息"""
        response = requests.post(
            f"{BASE_URL}/api/v1/chat",
            json={"message": None}
        )
        assert response.status_code == 400
        
        data = response.json()
        assert "error" in data

class TestSessionValidationErrors:
    """会话验证错误处理测试"""
    
    def test_invalid_session_id_format(self):
        """EH006: 无效会话ID格式"""
        response = requests.post(
            f"{BASE_URL}/api/v1/chat",
            json={"session_id": "invalid-format", "message": "test"}
        )
        assert response.status_code in [400, 404]
        
        data = response.json()
        assert "error" in data
    
    def test_nonexistent_session_id(self):
        """EH007: 不存在的会话ID"""
        import uuid
        fake_id = str(uuid.uuid4())
        
        response = requests.post(
            f"{BASE_URL}/api/v1/chat",
            json={"session_id": fake_id, "message": "test"}
        )
        assert response.status_code == 404
        
        data = response.json()
        assert "error" in data
        assert "session" in data["error"].lower() or "not found" in data["error"].lower()
    
    def test_expired_session_handling(self):
        """EH008: 过期会话ID处理"""
        # 创建会话
        create_resp = requests.post(f"{BASE_URL}/api/v1/sessions")
        session_id = create_resp.json()["session_id"]
        
        # 等待会话过期（需要配置较短的过期时间用于测试）
        # 这里假设测试环境配置了较短的过期时间
        time.sleep(10)
        
        # 尝试使用过期会话
        response = requests.post(
            f"{BASE_URL}/api/v1/chat",
            json={"session_id": session_id, "message": "test"}
        )
        assert response.status_code == 404
        
        data = response.json()
        assert "error" in data

class TestHTTPFormatErrors:
    """HTTP请求格式错误处理测试"""
    
    def test_wrong_content_type(self):
        """EH011: 错误Content-Type"""
        response = requests.post(
            f"{BASE_URL}/api/v1/chat",
            headers={"Content-Type": "text/plain"},
            data="test message"
        )
        assert response.status_code == 400
        
        data = response.json()
        assert "error" in data
    
    def test_invalid_json_format(self):
        """EH012: 无效JSON格式"""
        response = requests.post(
            f"{BASE_URL}/api/v1/chat",
            headers={"Content-Type": "application/json"},
            data="{invalid json format}"
        )
        assert response.status_code == 400
        
        data = response.json()
        assert "error" in data
    
    def test_empty_request_body(self):
        """EH013: 空请求体"""
        response = requests.post(
            f"{BASE_URL}/api/v1/chat",
            headers={"Content-Type": "application/json"}
        )
        assert response.status_code == 400
        
        data = response.json()
        assert "error" in data
    
    def test_wrong_http_method(self):
        """EH014: 错误HTTP方法"""
        response = requests.put(f"{BASE_URL}/api/v1/sessions")
        assert response.status_code == 405
        
        # 检查Allow头
        assert "Allow" in response.headers

class TestSystemResourceErrors:
    """系统资源错误处理测试"""
    
    @pytest.mark.skip(reason="需要特殊环境配置")
    def test_memory_exhaustion_handling(self):
        """EH016: 内存不足处理"""
        # 这个测试需要特殊的环境配置来模拟内存不足
        pass
    
    def test_history_length_limit(self):
        """EH018: 历史消息清理"""
        # 创建会话
        create_resp = requests.post(f"{BASE_URL}/api/v1/sessions")
        session_id = create_resp.json()["session_id"]
        
        # 发送超过限制数量的消息
        max_history = 10  # 假设配置的最大历史长度
        for i in range(max_history + 5):
            requests.post(f"{BASE_URL}/api/v1/chat", json={
                "session_id": session_id,
                "message": f"消息 {i}"
            })
        
        # 获取会话信息，验证历史消息被限制
        session_resp = requests.get(f"{BASE_URL}/api/v1/sessions/{session_id}")
        session_data = session_resp.json()
        
        # 验证消息数量不超过限制
        if "message_count" in session_data:
            assert session_data["message_count"] <= max_history

class TestExternalDependencyErrors:
    """外部依赖错误处理测试"""
    
    @patch('subprocess.run')
    def test_qcli_unavailable_handling(self, mock_subprocess):
        """EH028: Q CLI不可用处理"""
        # 模拟Q CLI不可用
        mock_subprocess.side_effect = FileNotFoundError("Q CLI not found")
        
        response = requests.post(
            f"{BASE_URL}/api/v1/chat",
            json={"message": "test"}
        )
        
        # 应该返回服务不可用错误
        assert response.status_code == 503
        
        data = response.json()
        assert "error" in data
    
    @patch('subprocess.run')
    def test_qcli_timeout_handling(self, mock_subprocess):
        """EH029: Q CLI超时处理"""
        import subprocess
        
        # 模拟Q CLI超时
        mock_subprocess.side_effect = subprocess.TimeoutExpired("q", 30)
        
        response = requests.post(
            f"{BASE_URL}/api/v1/chat",
            json={"message": "test"}
        )
        
        # 应该返回超时错误
        assert response.status_code in [500, 503]
        
        data = response.json()
        assert "error" in data
        assert "timeout" in data["error"].lower()

class TestConcurrencyErrors:
    """并发和竞争条件错误处理测试"""
    
    def test_concurrent_session_creation(self):
        """EH036: 会话ID冲突处理"""
        session_ids = []
        errors = []
        
        def create_session():
            try:
                response = requests.post(f"{BASE_URL}/api/v1/sessions")
                if response.status_code == 200:
                    session_ids.append(response.json()["session_id"])
                else:
                    errors.append(response.status_code)
            except Exception as e:
                errors.append(str(e))
        
        # 并发创建多个会话
        threads = []
        for _ in range(20):
            thread = threading.Thread(target=create_session)
            threads.append(thread)
            thread.start()
        
        for thread in threads:
            thread.join()
        
        # 验证所有会话ID唯一
        assert len(session_ids) == len(set(session_ids))
        assert len(errors) == 0  # 不应该有错误

class TestSecurityErrors:
    """安全相关错误处理测试"""
    
    def test_sql_injection_protection(self):
        """EH049: SQL注入防护"""
        malicious_input = "'; DROP TABLE sessions; --"
        
        response = requests.post(
            f"{BASE_URL}/api/v1/chat",
            json={"message": malicious_input}
        )
        
        # 应该正常处理，不应该导致系统错误
        assert response.status_code in [200, 400]
        
        # 验证服务仍然正常工作
        health_resp = requests.get(f"{BASE_URL}/health")
        assert health_resp.status_code == 200
    
    def test_xss_protection(self):
        """EH050: XSS攻击防护"""
        malicious_input = "<script>alert('xss')</script>"
        
        response = requests.post(
            f"{BASE_URL}/api/v1/chat",
            json={"message": malicious_input}
        )
        
        # 应该正常处理
        assert response.status_code == 200
        
        data = response.json()
        # 响应中不应该包含未转义的脚本标签
        assert "<script>" not in data.get("message", "")
    
    def test_path_traversal_protection(self):
        """EH051: 路径遍历攻击防护"""
        malicious_input = "请创建文件 ../../../etc/passwd"
        
        # 创建会话
        create_resp = requests.post(f"{BASE_URL}/api/v1/sessions")
        session_id = create_resp.json()["session_id"]
        
        # 发送恶意消息
        response = requests.post(
            f"{BASE_URL}/api/v1/chat",
            json={"session_id": session_id, "message": malicious_input}
        )
        
        # 应该正常处理，不应该创建系统文件
        assert response.status_code == 200
        
        # 检查会话文件列表，确保没有创建危险文件
        files_resp = requests.get(f"{BASE_URL}/api/v1/sessions/{session_id}/files")
        files = files_resp.json()["files"]
        
        for file_info in files:
            assert not file_info["path"].startswith("/")
            assert ".." not in file_info["path"]
            assert "passwd" not in file_info["name"].lower()

class TestErrorResponseFormat:
    """错误响应格式测试"""
    
    def test_error_response_structure(self):
        """验证错误响应的结构一致性"""
        # 触发一个已知错误
        response = requests.post(
            f"{BASE_URL}/api/v1/chat",
            json={"message": ""}
        )
        assert response.status_code == 400
        
        data = response.json()
        
        # 验证错误响应结构
        assert "error" in data
        assert isinstance(data["error"], str)
        
        # 可选字段
        optional_fields = ["code", "details", "timestamp"]
        for field in optional_fields:
            if field in data:
                assert data[field] is not None
    
    def test_error_message_localization(self):
        """验证错误消息本地化"""
        response = requests.post(
            f"{BASE_URL}/api/v1/chat",
            json={"message": ""}
        )
        assert response.status_code == 400
        
        data = response.json()
        error_message = data["error"]
        
        # 验证错误消息是中文（根据配置）
        # 这里可以检查是否包含中文字符
        chinese_chars = any('\u4e00' <= char <= '\u9fff' for char in error_message)
        assert chinese_chars or any(word in error_message.lower() for word in ["error", "invalid", "required"])

# 性能相关的错误处理测试
class TestPerformanceErrors:
    """性能相关错误处理测试"""
    
    def test_request_timeout_handling(self):
        """测试请求超时处理"""
        # 发送一个可能导致长时间处理的请求
        response = requests.post(
            f"{BASE_URL}/api/v1/chat",
            json={"message": "请生成一个包含10000行代码的程序"},
            timeout=30  # 设置客户端超时
        )
        
        # 验证服务器能在合理时间内响应或返回超时错误
        assert response.status_code in [200, 408, 500, 503]
    
    def test_concurrent_request_limit(self):
        """测试并发请求限制"""
        def make_request():
            try:
                response = requests.post(
                    f"{BASE_URL}/api/v1/chat",
                    json={"message": "test"},
                    timeout=10
                )
                return response.status_code
            except:
                return 0
        
        # 发送大量并发请求
        threads = []
        results = []
        
        for _ in range(100):
            thread = threading.Thread(target=lambda: results.append(make_request()))
            threads.append(thread)
            thread.start()
        
        for thread in threads:
            thread.join()
        
        # 验证系统能处理并发请求或优雅拒绝
        success_count = sum(1 for r in results if r == 200)
        error_count = sum(1 for r in results if r in [429, 503])
        
        # 至少应该有一些成功的请求
        assert success_count > 0
        # 如果有限制，应该返回适当的错误码
        if error_count > 0:
            assert error_count + success_count == len(results)

# 测试夹具
@pytest.fixture(autouse=True)
def cleanup_test_sessions():
    """自动清理测试会话"""
    yield
    # 测试后清理逻辑
    try:
        # 这里可以添加清理测试过程中创建的会话的逻辑
        pass
    except:
        pass  # 忽略清理错误
```

## 错误监控和日志分析

### 错误分类统计
```python
def analyze_error_logs():
    """分析错误日志，统计错误类型"""
    error_categories = {
        "input_validation": 0,
        "resource_errors": 0,
        "external_dependency": 0,
        "concurrency_errors": 0,
        "security_errors": 0,
        "unknown_errors": 0
    }
    
    # 分析日志文件
    # 实现日志分析逻辑
    
    return error_categories
```

### 错误恢复验证
```python
def verify_error_recovery():
    """验证错误后的系统恢复能力"""
    # 触发错误
    # 验证系统状态
    # 确认恢复正常
    pass
```

## 成功标准

- 输入验证错误处理覆盖率 100%
- 系统资源错误优雅处理 ≥ 95%
- 外部依赖错误处理 100%
- 安全攻击防护率 100%
- 错误响应格式一致性 100%
- 系统恢复能力 ≥ 99%
- 错误日志完整性 100%

## 测试执行计划

### 阶段1: 基础错误处理验证
- EH001-EH015: 输入验证错误
- EH028-EH032: 外部依赖错误

### 阶段2: 系统错误处理验证
- EH016-EH027: 系统资源错误
- EH033-EH035: 系统依赖错误

### 阶段3: 高级错误处理验证
- EH036-EH042: 并发错误处理
- EH043-EH048: 业务逻辑错误

### 阶段4: 安全错误处理验证
- EH049-EH056: 安全相关错误处理
- 渗透测试和安全扫描