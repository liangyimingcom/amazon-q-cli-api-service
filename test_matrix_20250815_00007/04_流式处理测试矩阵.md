# 流式处理测试矩阵

## 测试目标
验证Server-Sent Events (SSE)流式聊天功能的正确性、稳定性和性能。

## 测试环境
- 服务地址: http://localhost:8080
- 测试工具: pytest, requests, sseclient-py
- 流式接口: POST /api/v1/chat/stream

## 1. 基础流式功能测试

### 1.1 SSE协议合规性测试
| 测试用例ID | 测试描述 | 测试步骤 | 预期结果 | 优先级 |
|-----------|---------|---------|---------|--------|
| ST001 | SSE响应头验证 | 发送流式请求 | Content-Type: text/event-stream | 高 |
| ST002 | SSE事件格式验证 | 检查事件格式 | 符合SSE标准格式 | 高 |
| ST003 | 事件数据格式验证 | 解析事件数据 | 有效的JSON格式 | 高 |
| ST004 | 连接保持验证 | 长时间流式传输 | 连接保持稳定 | 高 |
| ST005 | 字符编码验证 | 发送中文消息 | UTF-8编码正确 | 高 |

### 1.2 事件类型测试
| 测试用例ID | 测试描述 | 事件类型 | 预期内容 | 优先级 |
|-----------|---------|---------|---------|--------|
| ST006 | 会话信息事件 | session | 包含session_id | 高 |
| ST007 | 消息块事件 | chunk | 包含message片段 | 高 |
| ST008 | 完成事件 | done | 标识传输完成 | 高 |
| ST009 | 错误事件 | error | 包含错误信息 | 高 |
| ST010 | 事件顺序验证 | 混合事件 | session -> chunks -> done | 高 |

## 2. 流式传输质量测试

### 2.1 消息完整性测试
| 测试用例ID | 测试描述 | 测试步骤 | 预期结果 | 优先级 |
|-----------|---------|---------|---------|--------|
| ST011 | 短消息流式传输 | 发送简单问题 | 完整接收所有消息块 | 高 |
| ST012 | 长消息流式传输 | 发送复杂问题 | 消息块拼接完整 | 高 |
| ST013 | 中文消息流式传输 | 发送中文问题 | 中文字符正确传输 | 高 |
| ST014 | 特殊字符传输 | 包含特殊符号的消息 | 特殊字符正确处理 | 中 |
| ST015 | 代码块传输 | 请求生成代码 | 代码格式保持完整 | 中 |

### 2.2 传输性能测试
| 测试用例ID | 测试描述 | 测试指标 | 预期结果 | 优先级 |
|-----------|---------|---------|---------|--------|
| ST016 | 首字节时间 | 发送请求到首个chunk | < 2秒 | 高 |
| ST017 | 传输延迟 | chunk间隔时间 | < 500ms | 中 |
| ST018 | 总传输时间 | 完整消息传输时间 | 合理范围内 | 中 |
| ST019 | 吞吐量测试 | 单位时间传输字符数 | 满足性能要求 | 中 |

## 3. 连接管理测试

### 3.1 连接建立和维护
| 测试用例ID | 测试描述 | 测试步骤 | 预期结果 | 优先级 |
|-----------|---------|---------|---------|--------|
| ST020 | 连接建立 | 发起流式请求 | 成功建立SSE连接 | 高 |
| ST021 | 连接保持 | 长时间保持连接 | 连接稳定不断开 | 高 |
| ST022 | 心跳机制 | 检查keep-alive | 定期发送心跳 | 中 |
| ST023 | 连接超时处理 | 超过超时时间 | 正确关闭连接 | 中 |

### 3.2 连接异常处理
| 测试用例ID | 测试描述 | 异常情况 | 预期处理 | 优先级 |
|-----------|---------|---------|---------|--------|
| ST024 | 客户端断开连接 | 客户端主动关闭 | 服务端正确清理 | 高 |
| ST025 | 网络中断恢复 | 模拟网络中断 | 错误处理和恢复 | 中 |
| ST026 | 服务端异常 | 服务端处理异常 | 发送error事件 | 高 |
| ST027 | 并发连接限制 | 超过连接限制 | 优雅拒绝新连接 | 中 |## 4. 并
发流式处理测试

### 4.1 多连接并发测试
| 测试用例ID | 测试描述 | 并发数量 | 预期结果 | 优先级 |
|-----------|---------|---------|---------|--------|
| ST028 | 低并发流式处理 | 5个并发连接 | 所有连接正常工作 | 高 |
| ST029 | 中等并发流式处理 | 20个并发连接 | 性能稳定，无阻塞 | 高 |
| ST030 | 高并发流式处理 | 50个并发连接 | 系统稳定运行 | 中 |
| ST031 | 极限并发测试 | 100个并发连接 | 优雅降级或限制 | 低 |

### 4.2 混合操作并发测试
| 测试用例ID | 测试描述 | 测试场景 | 预期结果 | 优先级 |
|-----------|---------|---------|---------|--------|
| ST032 | 流式与标准聊天混合 | 同时进行两种聊天 | 互不影响 | 高 |
| ST033 | 流式与会话管理混合 | 流式聊天时管理会话 | 操作正常执行 | 高 |
| ST034 | 多会话流式聊天 | 不同会话同时流式聊天 | 消息不混淆 | 高 |

## 5. 错误处理和边界测试

### 5.1 输入验证测试
| 测试用例ID | 测试描述 | 输入数据 | 预期结果 | 优先级 |
|-----------|---------|---------|---------|--------|
| ST035 | 空消息流式请求 | {"message": ""} | 返回error事件 | 高 |
| ST036 | 超长消息流式请求 | 4000+字符消息 | 返回error事件 | 中 |
| ST037 | 无效JSON格式 | 格式错误的请求 | HTTP 400错误 | 中 |
| ST038 | 缺少必需字段 | 无message字段 | 返回error事件 | 中 |
| ST039 | 无效会话ID | 不存在的session_id | 返回error事件 | 高 |

### 5.2 系统异常测试
| 测试用例ID | 测试描述 | 异常情况 | 预期处理 | 优先级 |
|-----------|---------|---------|---------|--------|
| ST040 | Q CLI不可用 | Q CLI服务异常 | 返回error事件 | 高 |
| ST041 | 内存不足 | 系统内存耗尽 | 优雅处理错误 | 中 |
| ST042 | 磁盘空间不足 | 存储空间不足 | 返回error事件 | 低 |
| ST043 | 网络超时 | Q CLI响应超时 | 超时错误处理 | 中 |

## 6. 流式数据一致性测试

### 6.1 消息顺序测试
| 测试用例ID | 测试描述 | 测试步骤 | 预期结果 | 优先级 |
|-----------|---------|---------|---------|--------|
| ST044 | 消息块顺序 | 检查chunk顺序 | 按正确顺序接收 | 高 |
| ST045 | 事件时间戳 | 检查事件时间 | 时间戳递增 | 中 |
| ST046 | 消息完整性校验 | 拼接所有chunk | 与标准聊天结果一致 | 高 |

### 6.2 会话上下文一致性
| 测试用例ID | 测试描述 | 测试步骤 | 预期结果 | 优先级 |
|-----------|---------|---------|---------|--------|
| ST047 | 流式聊天上下文保持 | 连续流式对话 | 上下文正确维护 | 高 |
| ST048 | 流式与标准聊天上下文 | 混合使用两种方式 | 上下文一致 | 高 |
| ST049 | 多会话上下文隔离 | 不同会话流式聊天 | 上下文不混淆 | 高 |

## 测试脚本示例

```python
import requests
import json
import threading
import time
import pytest
from sseclient import SSEClient

BASE_URL = "http://localhost:8080"

class TestStreamingChat:
    
    def test_basic_streaming(self):
        """ST001-ST003: 测试基础流式功能"""
        response = requests.post(
            f"{BASE_URL}/api/v1/chat/stream",
            json={"message": "你好"},
            stream=True
        )
        
        # 验证响应头
        assert response.status_code == 200
        assert "text/event-stream" in response.headers.get("content-type", "")
        
        # 解析SSE事件
        client = SSEClient(response)
        events = []
        
        for event in client.events():
            if event.data:
                try:
                    data = json.loads(event.data)
                    events.append(data)
                    if data.get("type") == "done":
                        break
                except json.JSONDecodeError:
                    pytest.fail(f"Invalid JSON in event: {event.data}")
        
        # 验证事件类型和顺序
        assert len(events) > 0
        assert events[0].get("type") == "session"
        assert events[-1].get("type") == "done"
        
        # 验证包含消息块
        chunk_events = [e for e in events if e.get("type") == "chunk"]
        assert len(chunk_events) > 0
    
    def test_message_completeness(self):
        """ST012: 测试消息完整性"""
        # 发送标准聊天请求作为对照
        standard_response = requests.post(
            f"{BASE_URL}/api/v1/chat",
            json={"message": "请详细介绍Python编程语言"}
        )
        standard_message = standard_response.json()["message"]
        
        # 发送流式聊天请求
        stream_response = requests.post(
            f"{BASE_URL}/api/v1/chat/stream",
            json={"message": "请详细介绍Python编程语言"},
            stream=True
        )
        
        # 收集所有消息块
        client = SSEClient(stream_response)
        message_chunks = []
        
        for event in client.events():
            if event.data:
                data = json.loads(event.data)
                if data.get("type") == "chunk":
                    message_chunks.append(data.get("message", ""))
                elif data.get("type") == "done":
                    break
        
        # 拼接消息并比较
        streamed_message = "".join(message_chunks)
        assert len(streamed_message) > 0
        # 注意：由于AI回复可能有差异，这里主要验证长度和基本内容
        assert len(streamed_message) > 100  # 详细介绍应该较长
    
    def test_concurrent_streaming(self):
        """ST028: 测试并发流式处理"""
        def stream_chat(message_suffix):
            response = requests.post(
                f"{BASE_URL}/api/v1/chat/stream",
                json={"message": f"你好{message_suffix}"},
                stream=True
            )
            
            client = SSEClient(response)
            events = []
            
            for event in client.events():
                if event.data:
                    data = json.loads(event.data)
                    events.append(data)
                    if data.get("type") == "done":
                        break
            
            return events
        
        # 创建5个并发流式聊天
        threads = []
        results = []
        
        def worker(suffix):
            result = stream_chat(suffix)
            results.append(result)
        
        for i in range(5):
            thread = threading.Thread(target=worker, args=(i,))
            threads.append(thread)
            thread.start()
        
        # 等待所有线程完成
        for thread in threads:
            thread.join()
        
        # 验证所有请求都成功完成
        assert len(results) == 5
        for result in results:
            assert len(result) > 0
            assert result[-1].get("type") == "done"
    
    def test_connection_interruption(self):
        """ST024: 测试连接中断处理"""
        response = requests.post(
            f"{BASE_URL}/api/v1/chat/stream",
            json={"message": "请写一个很长的故事"},
            stream=True
        )
        
        client = SSEClient(response)
        event_count = 0
        
        # 接收几个事件后主动断开
        for event in client.events():
            event_count += 1
            if event_count >= 3:
                break
        
        # 关闭连接
        response.close()
        
        # 验证没有异常抛出，连接正常关闭
        assert event_count >= 3
    
    def test_error_handling(self):
        """ST035: 测试错误处理"""
        response = requests.post(
            f"{BASE_URL}/api/v1/chat/stream",
            json={"message": ""},  # 空消息
            stream=True
        )
        
        client = SSEClient(response)
        events = []
        
        for event in client.events():
            if event.data:
                data = json.loads(event.data)
                events.append(data)
                if data.get("type") in ["done", "error"]:
                    break
        
        # 应该收到错误事件
        error_events = [e for e in events if e.get("type") == "error"]
        assert len(error_events) > 0
    
    def test_streaming_performance(self):
        """ST016: 测试流式性能"""
        start_time = time.time()
        
        response = requests.post(
            f"{BASE_URL}/api/v1/chat/stream",
            json={"message": "你好"},
            stream=True
        )
        
        client = SSEClient(response)
        first_chunk_time = None
        
        for event in client.events():
            if event.data:
                data = json.loads(event.data)
                if data.get("type") == "chunk" and first_chunk_time is None:
                    first_chunk_time = time.time()
                elif data.get("type") == "done":
                    break
        
        # 验证首字节时间
        if first_chunk_time:
            first_byte_time = first_chunk_time - start_time
            assert first_byte_time < 2.0  # 首字节时间应小于2秒
```

## 性能基准测试

### 流式传输延迟测试
```python
def test_streaming_latency():
    """测试流式传输延迟"""
    response = requests.post(
        f"{BASE_URL}/api/v1/chat/stream",
        json={"message": "请详细介绍机器学习"},
        stream=True
    )
    
    client = SSEClient(response)
    chunk_times = []
    last_time = time.time()
    
    for event in client.events():
        if event.data:
            current_time = time.time()
            data = json.loads(event.data)
            
            if data.get("type") == "chunk":
                chunk_times.append(current_time - last_time)
                last_time = current_time
            elif data.get("type") == "done":
                break
    
    # 验证chunk间隔时间
    if chunk_times:
        avg_interval = sum(chunk_times) / len(chunk_times)
        assert avg_interval < 0.5  # 平均间隔应小于500ms
```

### 并发性能测试
```python
def test_concurrent_streaming_performance():
    """测试并发流式性能"""
    import concurrent.futures
    
    def single_stream():
        start = time.time()
        response = requests.post(
            f"{BASE_URL}/api/v1/chat/stream",
            json={"message": "你好"},
            stream=True
        )
        
        client = SSEClient(response)
        for event in client.events():
            if event.data:
                data = json.loads(event.data)
                if data.get("type") == "done":
                    break
        
        return time.time() - start
    
    # 并发执行10个流式请求
    with concurrent.futures.ThreadPoolExecutor(max_workers=10) as executor:
        futures = [executor.submit(single_stream) for _ in range(10)]
        durations = [future.result() for future in futures]
    
    # 验证所有请求都在合理时间内完成
    assert all(d < 30 for d in durations)  # 每个请求应在30秒内完成
    assert max(durations) < 60  # 最长请求不超过60秒
```

## 测试工具和环境

### 依赖安装
```bash
pip install sseclient-py requests pytest
```

### 测试配置
```python
# conftest.py
import pytest

@pytest.fixture(scope="session")
def base_url():
    return "http://localhost:8080"

@pytest.fixture
def sse_headers():
    return {
        "Accept": "text/event-stream",
        "Cache-Control": "no-cache"
    }
```

## 成功标准

- SSE协议合规性 100%
- 消息完整性 100%
- 首字节时间 < 2秒
- 平均chunk间隔 < 500ms
- 并发处理能力 ≥ 20个连接
- 错误处理覆盖率 100%
- 连接稳定性 ≥ 99%

## 测试执行计划

### 阶段1: 基础功能验证
- ST001-ST010: SSE协议和事件类型
- ST011-ST015: 消息完整性

### 阶段2: 性能和并发验证
- ST016-ST019: 传输性能
- ST028-ST034: 并发处理

### 阶段3: 异常和边界验证
- ST035-ST043: 错误处理
- ST044-ST049: 数据一致性

### 阶段4: 长期稳定性验证
- 长时间运行测试
- 内存泄漏检测
- 连接池管理验证